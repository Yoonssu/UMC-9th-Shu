시니어 미션

[1]

1. 전통적인 서블릿 기반 개발

* 구조: 각 요청에 대해 별도의 서블릿을 만들거나, 하나의 서블릿에서 doGet(), doPost() 등으로 요청을 분기합니다.
* 핵심 요소:

  * HttpServlet: HTTP 요청을 처리하는 기본 클래스.
  * doGet(), doPost(): HTTP 요청 방식(GET, POST)에 따라 호출되는 메서드.
  * 구현 방식: HttpServlet을 상속받아 서블릿 클래스를 만들고, 클라이언트의 요청을 처리한 후 응답을 생성합니다.
* 장점: 자바 EE 스펙에 정의된 표준 방식으로, 웹 애플리케이션 개발의 기본적인 메커니즘을 이해할 수 있습니다.
* 단점: 요청마다 개별 서블릿을 생성하거나 분기 코드가 많아져 코드가 복잡해지고 유지보수가 어려워질 수 있습니다.

2. Spring MVC 개발

* 구조: DispatcherServlet이 클라이언트의 모든 요청을 받아 컨트롤러에게 위임하는 프론트 컨트롤러(Front Controller) 패턴을 사용합니다.
* 핵심 요소:

  * DispatcherServlet: Spring MVC 프레임워크의 핵심으로, 클라이언트의 요청을 받아서 적절한 컨트롤러에 위임하고, 뷰를 선택하며, 최종 결과물을 생성합니다.
  * @Controller: 해당 클래스가 컨트롤러임을 나타내는 어노테이션입니다.
  * @RequestMapping: 특정 URL과 컨트롤러의 메서드를 연결하는 어노테이션입니다.
* 구현 방식: 컨트롤러 클래스에 @Controller와 @RequestMapping을 붙이고, 메서드를 구현하여 요청을 처리합니다. DispatcherServlet이 이 컨트롤러를 찾아 호출합니다.
* 장점:

  * 코드가 간결해지고, 개발자는 비즈니스 로직에 집중할 수 있습니다.
  * DispatcherServlet이 요청-응답 처리를 도와 웹 애플리케이션의 구조화 및 유지보수가 용이해집니다.
  * Front Controller 패턴을 따르므로 요청을 중앙에서 처리하여 일관성 있는 처리가 가능합니다.

[2] 전통적인 서블릿 기반 개발 vs Spring MVC

| 항목       | 전통적인 서블릿(Servlet) 기반    | Spring MVC                                      |
| -------- | ----------------------- | ----------------------------------------------- |
| 핵심 클래스   | HttpServlet             | @Controller, @RequestMapping, DispatcherServlet |
| 요청 처리 방식 | doGet(), doPost() 오버라이딩 | 메서드에 @RequestMapping 등으로 요청 매핑                  |
| 라우팅 처리   | web.xml에 URL과 클래스 직접 매핑 | 어노테이션 기반으로 간편하게 매핑                              |
| 코드 구조    | 비즈니스 로직과 요청 처리 코드가 뒤섞임  | 컨트롤러/서비스/뷰로 관심사 분리 (MVC)                        |
| 유연성      | 기능 확장/재사용 어려움           | 유연한 컴포넌트 기반 구조                                  |
| 뷰 연결     | 직접 HTML 또는 JSP 포워딩 처리   | ViewResolver 통해 자동 연결 가능                        |

[3] DispatcherServlet이 내부적으로 요청을 처리하는 방식 단계별 분석

* 서블 요청/응답을 HTTP 서블릿 요청/응답으로 변환
* Http Method에 따른 처리 작업 진행
* 요청에 대한 공통 처리 작업 진행
* 컨트롤러로 요청을 위임

  1. 요청에 매핑되는 HandlerExecutionChain 조회
  2. 요청을 처리할 HandlerAdapter 조회
  3. HandlerAdapter를 통해 컨트롤러 메소드 호출(HandlerExecutionChain 처리)

[4] AOP가 무엇인지, 그리고 왜 필요한지 개념적으로 정리

OOP와 AOP의 차이점 분석

| 구분    | OOP                  | AOP               |
| ----- | -------------------- | ----------------- |
| 핵심 관점 | 객체 단위의 책임 분리         | 횡단 관심사의 모듈화       |
| 적용 방식 | 클래스 상속, 인터페이스 구현     | 프록시, 위빙(Weaving)  |
| 중복 문제 | 횡단 기능이 여러 클래스에 흩어짐   | 공통 기능을 Aspect로 분리 |
| 장점    | 코드 구조화, 재사용성         | 중복 제거, 유지보수 용이    |
| 예시    | UserService에 로직 + 로깅 | 로깅은 Aspect로 따로 관리 |

AOP의 핵심 개념

* JoinPoint: 프로그램 실행 중 Advice가 적용될 수 있는 지점. 예: 메서드 호출 시점, 예외 발생 시점.
* Pointcut: 어떤 JoinPoint에 Advice를 적용할지 정의. 표현식(예: execution(* com.app.service.*.*(..))).
* Advice: 실제로 실행되는 부가 기능 코드. 종류: Before, AfterReturning, AfterThrowing, After, Around.
* Aspect: Pointcut + Advice를 합쳐 놓은 모듈. 횡단 관심사를 캡슐화한 단위.
* Weaving: Pointcut으로 지정된 JoinPoint에 Aspect를 실제 코드에 적용하는 과정. 컴파일 타임, 로드 타임, 런타임 위빙이 있음.

런타임 위빙 vs 컴파일 타임 위빙

| 구분 | 컴파일 타임 위빙          | 로드 타임 위빙            | 런타임 위빙 (Spring AOP)   |
| -- | ------------------ | ------------------- | --------------------- |
| 방식 | 컴파일 시 바이트코드에 직접 반영 | 클래스 로딩 시점에 바이트코드 수정 | 프록시 객체를 생성하여 위빙       |
| 기술 | AspectJ 컴파일러(ajc)  | JVM 클래스 로더          | Spring AOP (Proxy 기반) |
| 장점 | 성능 최적              | 유연성, Aspect 교체 가능   | 가장 흔하게 사용, 설정 간단      |
| 단점 | 빌드 환경 복잡           | 실행 시 약간의 오버헤드       | 프록시 기반 → 메서드 호출만 적용   |

어노테이션 기반 AOP 동작 방식

* @Aspect를 붙이면 Spring이 BeanPostProcessor로 Aspect를 감지.
* Before, Around 등의 Advice는 내부적으로 Proxy 메서드에 연결.
* AnnotationAwareAspectJAutoProxyCreator가 실제 프록시 객체를 생성.

Spring에서 AOP 프록시 패턴 활용 원리

Proxy 패턴 기반

* Spring AOP는 프록시 객체를 사용.
* 실제 Bean 대신 프록시가 주입되고, 호출 시 프록시가 Advice를 적용한 뒤 실제 메서드를 실행.

프록시 생성 방식

* JDK 동적 프록시: 인터페이스 기반
* CGLIB 프록시: 클래스 상속 기반
* Spring은 자동으로 적절한 방식을 선택

동작 흐름

1. 스프링 컨테이너가 @EnableAspectJAutoProxy 등을 통해 AOP 활성화
2. 빈 생성 시 프록시 객체를 대신 등록
3. 클라이언트가 메서드를 호출하면 프록시가 가로채고, Pointcut 매칭 확인
4. 매칭되면 Advice 실행 → 실제 대상 메서드 호출
